#!/usr/bin/python
"""
watch for heater commands and send pin signals to io.solarisParport

also watch commands for the remote-controlled lights.

This can run anywhere; it listens for command pings and PUTs pin settings to other URIs according to the device configurations
"""
import sys, time, atexit, logging, traceback, urllib, jsonlib

sys.path.append('..') # for commandinference
from twisted.internet import reactor
from rdflib import RDF, URIRef
import restkit
from xml.utils import iso8601
from cmdline import getCommandLog
from commandinference.db import CMD, CL, ROOM

from twisted.internet import task
from twisted.web.client import getPage
from nevow import rend, inevow
from nevow.appserver import NevowSite

log = logging.getLogger()
logging.basicConfig(level=logging.INFO, format="%(created)s %(asctime)s %(levelname)-5s %(filename)s:%(lineno)d: %(message)s")
logging.getLogger('restkit.client').setLevel(logging.WARN)

commandLog = getCommandLog()

def setOutputPins():
    # not sure where this config is going to go. Here is wrong, since an
    # arduinoport restart after portUpdate restart forgets everything!
    restkit.request(method="PUT", url="http://bang:9056/pin/d4/mode", body="output")
    restkit.request(method="PUT", url="http://bang:9056/pin/d5/mode", body="output")
    restkit.request(method="PUT", url="http://bang:9056/pin/d6/mode", body="output")
    restkit.request(method="PUT", url="http://bang:9056/pin/d7/mode", body="output")
    restkit.request(method="PUT", url="http://bang:9056/pin/d8/mode", body="output")

class Loop(object):
    def __init__(self):
        self.lastMsg = None
        self.lastHeater = None
        self.lastLight = {} # cmdclass : value

        self.pollClasses = [row['cls'] for row in commandLog.graph.queryd(
            "SELECT ?cls WHERE { ?cls a cmd:PollMe . }")]
                
    def poll(self):
        if 1:
            for commandClass in self.pollClasses:
                cmd, t, user = commandLog.lastCommandOfClass(commandClass)
                log.debug("cls=%s cmd=%s t=%s", commandClass, cmd, t)
                self.onCommand(commandClass, cmd)

        self.pollHeater()

    def onCommand(self, commandClass, cmd):
        if commandClass == URIRef("http://bigasterisk.com/magma/cmd/Heater"):
            # legacy handler
            self.pollHeater()
            return
        if commandClass == URIRef("http://bigasterisk.com/magma/cmd/TimedOn"):
            # related to heater, redundant.
            return
        
        value = commandLog.graph.value(cmd, CL['value'])
        if value is None:
            raise ValueError(
                "command %s has no cl:value to set the light to" % cmd)

        if self.lastLight.get(commandClass) == value:
            return

        try:
            self.setLight(commandClass, cmd, value)
        except Exception, e:
            traceback.print_exc()
            return
        self.lastLight[commandClass] = value

    def setLight(self, commandClass, cmd, value):
        """
        cmd:bedroomRedLightOff :oneShot [ a :ParportPin; :host "somehost"; :port "/dev/parport0"; :bit 1 ]

        or

        cmd:frontLightOff :clearPin [a :ParportPin; :host "slash"; :port "/dev/parport0"; :bit 1 . ]
        
        """
        val = commandLog.graph.value
        log.info("need to set %s to %s", commandClass, value)
        outPinUri = val(cmd, ROOM['oneShot'])
        if outPinUri:
            log.info("oneshot on %s", outPinUri)
            self.sendBit(outPinUri, 1)
            time.sleep(float(val(cmd, ROOM['pulse'], default=.5)))
            self.sendBit(outPinUri, 0)
            return

        setPin = val(cmd, ROOM['setPin'])
        if setPin:
            self.sendBit(setPin, 1)
            return

        clrPin = val(cmd, ROOM['clearPin'])
        if clrPin:
            self.sendBit(clrPin, 0)
            return

        raise NotImplementedError("don't know how to set %s" % cmd)

    def pollHeater(self):
        # this is a special case mostly because it was written
        # first. Hopefully it can be folded into the more-general
        # poller above.
        try:
            cmd, t, user = commandLog.lastCommandOfClass(CMD['Heater'])
            now = time.time()
            if cmd == CMD['heaterOff']:
                self.sendHeater(False)
            elif commandLog.graph.contains((cmd, RDF.type, CMD['TimedOn'])):
                mins = float(commandLog.graph.value(cmd, CL['onForMins']))
                endTime = iso8601.parse(str(t)) + mins * 60
                if endTime > now:
                    self.boringMsg("heater on, %s min left" %
                                   ((endTime - now) / 60))
                    self.sendHeater(True)
                else:
                    # last cmd expired; we should now look at previous ones
                    self.sendHeater(False)
        except Exception, e:
            log.error("emergency off: %s" % e)
            self.sendHeater(False)
            raise

    def boringMsg(self, msg, minInterval=120):
        """throttled print"""
        now = time.time()
        if now - minInterval > self.lastMsg:
            log.info(msg)
            self.lastMsg = now

    def sendBit(self, pinUri, value):
        putUrl = commandLog.graph.value(pinUri, ROOM['putUrl'])
        log.info("set %s by putting %s to %s" % (pinUri, value, putUrl))
        if putUrl:
            setOutputPins()
            r = restkit.request(method="PUT", url=putUrl, body=str(int(value)))
            if not r.status.startswith('2'):
                raise ValueError("%s returned %r" % (putUrl, r.status))
            return
        
    def sendHeater(self, on):
        if on != self.lastHeater: # this assumes we're the only one
                                # talking to the heater pin, which
                                # might not be true
            self.sendBit(
                URIRef("http://projects.bigasterisk.com/device/heater"),
                int(on))
        self.lastHeater = on

loop = Loop()
atexit.register(lambda: loop.sendHeater(False))

def postForm(url, kv):
    s = urllib.urlencode(kv)
    return getPage(url, method='POST', postdata=s,
            headers={'Content-Type': 'application/x-www-form-urlencoded'})   

postForm('http://bang:9030/subscribe',
         {'hub.mode' : 'subscribe',
          'hub.callback' : 'http://bang:9055/newCommand',
          'hub.topic' : 'newCommand',
          'hub.verify' : 'sync'})

# this matters only for initial state, and for the heater timeout, and
# to catch commands we might have missed (?!)
task.LoopingCall(loop.poll).start(30)

class Root(rend.Page):   
    def child_newCommand(self, ctx):
        request = inevow.IRequest(ctx)
        if ctx.arg('hub.mode') == 'subscribe':
            request.setResponseCode(202)
            return ctx.arg('hub.challenge')

        d = jsonlib.read(request.content.read())
        log.debug("incoming command %s", d)
        loop.onCommand(URIRef(d['commandClass']), URIRef(d['command']))
        
        return "ok"

setOutputPins()
site = NevowSite(Root())
reactor.listenTCP(9055, site)
reactor.run()
